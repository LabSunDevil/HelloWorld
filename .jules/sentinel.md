## 2025-02-20 - [Second-Order SQL Injection in SQLite]
**Vulnerability:** A second-order SQL injection vulnerability was found in the `/api/recommendations` endpoint. The application retrieved `videoId`s from the `views` table (which were controlled by user input and not validated as integers) and concatenated them directly into a `NOT IN (...)` SQL clause.
**Learning:** SQLite's dynamic typing system allows storing strings in `INTEGER` columns without error. This means that even if a column is defined as `INTEGER` (or `userId` in `views` table), one cannot assume the data retrieved from it is safe or numeric. Vulnerabilities can persist even when the initial insertion uses parameterized queries if the data is later used unsafe in another query (Second-Order SQL Injection).
**Prevention:** Always use parameterized queries for all SQL statements, including `IN` and `NOT IN` clauses. For dynamic lists, generate a placeholder string (e.g., `?,?,?`) based on the input length. Additionally, strictly validate input types (e.g., ensure `videoId` is an integer) before insertion into the database as a defense-in-depth measure.
